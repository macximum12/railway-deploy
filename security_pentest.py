#!/usr/bin/env python3
"""
Comprehensive Security Penetration Testing Suite
Tests brute force protection, session security, and other vulnerabilities
"""

import requests
import time
import threading
from datetime import datetime
import json
import random
import string

class SecurityTester:
    def __init__(self, base_url="http://127.0.0.1:5000"):
        self.base_url = base_url
        self.session = requests.Session()
        self.results = {
            'brute_force': {},
            'session_security': {},
            'input_validation': {},
            'rate_limiting': {},
            'authentication': {},
            'csrf_protection': {},
            'recommendations': []
        }
        
    def log_test(self, category, test_name, result, details=""):
        """Log test results"""
        timestamp = datetime.now().isoformat()
        if category not in self.results:
            self.results[category] = {}
            
        self.results[category][test_name] = {
            'result': result,
            'details': details,
            'timestamp': timestamp
        }
        
        status = "‚úÖ PASS" if result == "PASS" else "‚ùå FAIL" if result == "FAIL" else "‚ö†Ô∏è  WARN"
        print(f"{status} [{category}] {test_name}: {details}")

    def test_brute_force_protection(self):
        """Test brute force attack protection"""
        print("\nüîí TESTING BRUTE FORCE PROTECTION")
        print("=" * 50)
        
        # Test 1: Multiple failed login attempts from same IP
        print("Testing multiple failed login attempts...")
        failed_attempts = 0
        
        for i in range(15):  # Try 15 failed attempts
            try:
                response = self.session.post(f"{self.base_url}/login", 
                                           data={
                                               'username': 'admin',
                                               'password': f'wrongpass{i}'
                                           }, 
                                           timeout=10)
                
                if response.status_code == 200 and "Account temporarily locked" in response.text:
                    self.log_test('brute_force', 'Account_Lockout', 'PASS', 
                                f'Account locked after {i+1} attempts')
                    break
                elif response.status_code == 200 and ("Invalid username or password" in response.text or "error" in response.text.lower()):
                    failed_attempts += 1
                    if i >= 10:  # If we can still attempt after 10 tries
                        self.log_test('brute_force', 'Account_Lockout', 'FAIL', 
                                    f'No lockout after {i+1} attempts')
                        break
                        
                time.sleep(0.5)  # Small delay between attempts
                
            except Exception as e:
                self.log_test('brute_force', 'Account_Lockout', 'ERROR', f'Request failed: {str(e)}')
                break
        
        # Test 2: Rate limiting effectiveness
        print("Testing rate limiting...")
        rapid_requests = 0
        start_time = time.time()
        
        for i in range(50):  # Try 50 rapid requests
            try:
                response = self.session.get(f"{self.base_url}/login", timeout=5)
                if response.status_code == 429:  # Too Many Requests
                    self.log_test('brute_force', 'Rate_Limiting', 'PASS', 
                                f'Rate limiting triggered after {i+1} requests')
                    break
                elif response.status_code == 200:
                    rapid_requests += 1
                    
                if time.time() - start_time > 10:  # Stop after 10 seconds
                    break
                    
            except Exception as e:
                if "timeout" in str(e).lower():
                    self.log_test('brute_force', 'Rate_Limiting', 'PASS', 
                                'Server applying delays/timeouts')
                    break
                    
        if rapid_requests >= 45:
            self.log_test('brute_force', 'Rate_Limiting', 'WARN', 
                        f'Completed {rapid_requests} rapid requests without rate limiting')

    def test_session_security(self):
        """Test session management security"""
        print("\nüîê TESTING SESSION SECURITY")
        print("=" * 50)
        
        # Test 1: Session timeout
        print("Testing session timeout...")
        try:
            # Try to access protected route without login
            response = self.session.get(f"{self.base_url}/settings")
            if response.status_code == 302 and "/login" in response.headers.get('Location', ''):
                self.log_test('session_security', 'Session_Protection', 'PASS', 
                            'Redirects to login for protected routes')
            else:
                self.log_test('session_security', 'Session_Protection', 'FAIL', 
                            'No proper redirect for protected routes')
                            
        except Exception as e:
            self.log_test('session_security', 'Session_Protection', 'ERROR', str(e))
        
        # Test 2: Session fixation
        print("Testing session fixation protection...")
        try:
            # Get initial session
            response1 = self.session.get(f"{self.base_url}/login")
            cookies_before = self.session.cookies.copy()
            
            # Attempt login
            response2 = self.session.post(f"{self.base_url}/login", 
                                        data={'username': 'admin', 'password': 'admin'})
            cookies_after = self.session.cookies.copy()
            
            if cookies_before != cookies_after:
                self.log_test('session_security', 'Session_Fixation', 'PASS', 
                            'Session regenerated after login')
            else:
                self.log_test('session_security', 'Session_Fixation', 'WARN', 
                            'Session not regenerated after login')
                            
        except Exception as e:
            self.log_test('session_security', 'Session_Fixation', 'ERROR', str(e))

    def test_input_validation(self):
        """Test input validation and injection vulnerabilities"""
        print("\nüõ°Ô∏è  TESTING INPUT VALIDATION")
        print("=" * 50)
        
        # Test 1: SQL Injection attempts
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "admin'--",
            "'; EXEC xp_cmdshell('dir') --"
        ]
        
        for payload in sql_payloads:
            try:
                response = self.session.post(f"{self.base_url}/login", 
                                           data={'username': payload, 'password': 'test'})
                
                if "error" in response.text.lower() and "sql" in response.text.lower():
                    self.log_test('input_validation', 'SQL_Injection_Detection', 'FAIL', 
                                f'SQL error exposed with payload: {payload[:20]}...')
                    break
                elif response.status_code == 200:
                    self.log_test('input_validation', 'SQL_Injection_Protection', 'PASS', 
                                'No SQL errors exposed')
                    
            except Exception as e:
                continue
        
        # Test 2: XSS attempts
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>"
        ]
        
        for payload in xss_payloads:
            try:
                response = self.session.post(f"{self.base_url}/login", 
                                           data={'username': payload, 'password': 'test'})
                
                if payload in response.text and "<script>" in response.text:
                    self.log_test('input_validation', 'XSS_Protection', 'FAIL', 
                                f'XSS payload not sanitized: {payload[:20]}...')
                    break
                else:
                    self.log_test('input_validation', 'XSS_Protection', 'PASS', 
                                'XSS payloads properly handled')
                    
            except Exception as e:
                continue

    def test_authentication_bypass(self):
        """Test authentication bypass vulnerabilities"""
        print("\nüîì TESTING AUTHENTICATION BYPASS")
        print("=" * 50)
        
        # Test 1: Direct URL access
        protected_urls = [
            '/admin/users',
            '/settings',
            '/admin/security-status',
            '/activity-logs'
        ]
        
        for url in protected_urls:
            try:
                response = self.session.get(f"{self.base_url}{url}")
                if response.status_code == 200:
                    self.log_test('authentication', 'URL_Protection', 'FAIL', 
                                f'Direct access allowed to {url}')
                elif response.status_code == 302:
                    self.log_test('authentication', 'URL_Protection', 'PASS', 
                                f'Proper redirect for {url}')
                                
            except Exception as e:
                continue
        
        # Test 2: Parameter manipulation
        try:
            response = self.session.get(f"{self.base_url}/login?username=admin&auto_login=true")
            if "logged in" in response.text.lower():
                self.log_test('authentication', 'Parameter_Manipulation', 'FAIL', 
                            'Auto-login via URL parameters')
            else:
                self.log_test('authentication', 'Parameter_Manipulation', 'PASS', 
                            'No parameter-based bypass')
                            
        except Exception as e:
            self.log_test('authentication', 'Parameter_Manipulation', 'ERROR', str(e))

    def test_csrf_protection(self):
        """Test CSRF protection"""
        print("\nüõ°Ô∏è  TESTING CSRF PROTECTION")
        print("=" * 50)
        
        try:
            # Check if CSRF tokens are present
            response = self.session.get(f"{self.base_url}/login")
            if "csrf_token" in response.text or "_token" in response.text:
                self.log_test('csrf_protection', 'CSRF_Token_Present', 'PASS', 
                            'CSRF tokens detected in forms')
            else:
                self.log_test('csrf_protection', 'CSRF_Token_Present', 'WARN', 
                            'No CSRF tokens detected')
                            
        except Exception as e:
            self.log_test('csrf_protection', 'CSRF_Token_Present', 'ERROR', str(e))

    def test_security_headers(self):
        """Test for security headers"""
        print("\nüõ°Ô∏è  TESTING SECURITY HEADERS")
        print("=" * 50)
        
        try:
            response = self.session.get(f"{self.base_url}/login")
            headers = response.headers
            
            # Check for security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME sniffing protection',
                'X-XSS-Protection': 'XSS filtering',
                'Content-Security-Policy': 'Content Security Policy',
                'Referrer-Policy': 'Referrer policy'
            }
            
            headers_found = 0
            for header, description in security_headers.items():
                if header in headers:
                    headers_found += 1
                    self.log_test('security_headers', f'{header}_Present', 'PASS', 
                                f'{description}: {headers[header]}')
                else:
                    self.log_test('security_headers', f'{header}_Missing', 'FAIL', 
                                f'Missing {description}')
            
            # Overall score
            if headers_found >= 4:
                self.log_test('security_headers', 'Overall_Headers', 'PASS', 
                            f'{headers_found}/5 security headers present')
            else:
                self.log_test('security_headers', 'Overall_Headers', 'FAIL', 
                            f'Only {headers_found}/5 security headers present')
                            
        except Exception as e:
            self.log_test('security_headers', 'Header_Test', 'ERROR', str(e))

    def test_password_hashing(self):
        """Test if passwords are properly hashed"""
        print("\nüîê TESTING PASSWORD SECURITY")
        print("=" * 50)
        
        # This is a black-box test - we can infer password hashing by testing behavior
        try:
            # Try to login with known credentials
            response = self.session.post(f"{self.base_url}/login", 
                                       data={'username': 'admin', 'password': 'admin'})
            
            if response.status_code == 302 or "dashboard" in response.text.lower():
                self.log_test('password_security', 'Authentication_Working', 'PASS', 
                            'Authentication mechanism functional')
                            
                # Test password migration on login
                response2 = self.session.post(f"{self.base_url}/login", 
                                            data={'username': 'admin', 'password': 'admin'})
                if response2.status_code == 302:
                    self.log_test('password_security', 'Password_Migration', 'PASS', 
                                'Password hashing likely implemented (transparent migration)')
            else:
                self.log_test('password_security', 'Authentication_Working', 'FAIL', 
                            'Authentication not working')
                            
        except Exception as e:
            self.log_test('password_security', 'Password_Test', 'ERROR', str(e))

    def test_concurrent_attacks(self):
        """Test system behavior under concurrent attacks"""
        print("\n‚ö° TESTING CONCURRENT ATTACK RESISTANCE")
        print("=" * 50)
        
        def attack_thread(thread_id):
            """Individual attack thread"""
            try:
                session = requests.Session()
                for i in range(10):
                    response = session.post(f"{self.base_url}/login", 
                                          data={'username': f'user{thread_id}', 
                                               'password': f'pass{i}'}, 
                                          timeout=5)
                    time.sleep(0.1)
            except:
                pass
        
        # Launch concurrent attack threads
        threads = []
        for i in range(5):
            thread = threading.Thread(target=attack_thread, args=(i,))
            threads.append(thread)
            thread.start()
        
        # Wait for completion
        for thread in threads:
            thread.join(timeout=30)
        
        # Test if server is still responsive
        try:
            response = self.session.get(f"{self.base_url}/login", timeout=10)
            if response.status_code == 200:
                self.log_test('brute_force', 'Concurrent_Attack_Resistance', 'PASS', 
                            'Server remains responsive under concurrent attacks')
            else:
                self.log_test('brute_force', 'Concurrent_Attack_Resistance', 'FAIL', 
                            'Server unresponsive after concurrent attacks')
        except Exception as e:
            self.log_test('brute_force', 'Concurrent_Attack_Resistance', 'FAIL', 
                        f'Server error after attacks: {str(e)}')
        """Test system behavior under concurrent attacks"""
        print("\n‚ö° TESTING CONCURRENT ATTACK RESISTANCE")
        print("=" * 50)
        
        def attack_thread(thread_id):
            """Individual attack thread"""
            try:
                session = requests.Session()
                for i in range(10):
                    response = session.post(f"{self.base_url}/login", 
                                          data={'username': f'user{thread_id}', 
                                               'password': f'pass{i}'}, 
                                          timeout=5)
                    time.sleep(0.1)
            except:
                pass
        
        # Launch concurrent attack threads
        threads = []
        for i in range(5):
            thread = threading.Thread(target=attack_thread, args=(i,))
            threads.append(thread)
            thread.start()
        
        # Wait for completion
        for thread in threads:
            thread.join(timeout=30)
        
        # Test if server is still responsive
        try:
            response = self.session.get(f"{self.base_url}/login", timeout=10)
            if response.status_code == 200:
                self.log_test('brute_force', 'Concurrent_Attack_Resistance', 'PASS', 
                            'Server remains responsive under concurrent attacks')
            else:
                self.log_test('brute_force', 'Concurrent_Attack_Resistance', 'FAIL', 
                            'Server unresponsive after concurrent attacks')
        except Exception as e:
            self.log_test('brute_force', 'Concurrent_Attack_Resistance', 'FAIL', 
                        f'Server error after attacks: {str(e)}')

    def generate_security_report(self):
        """Generate comprehensive security report"""
        print("\n" + "="*70)
        print("üîç COMPREHENSIVE SECURITY ASSESSMENT REPORT")
        print("="*70)
        
        total_tests = 0
        passed_tests = 0
        failed_tests = 0
        warnings = 0
        
        for category, tests in self.results.items():
            if category == 'recommendations':
                continue
                
            print(f"\nüìã {category.upper().replace('_', ' ')}")
            print("-" * 40)
            
            for test_name, result in tests.items():
                total_tests += 1
                status_icon = "‚úÖ" if result['result'] == 'PASS' else "‚ùå" if result['result'] == 'FAIL' else "‚ö†Ô∏è "
                print(f"{status_icon} {test_name.replace('_', ' ')}: {result['details']}")
                
                if result['result'] == 'PASS':
                    passed_tests += 1
                elif result['result'] == 'FAIL':
                    failed_tests += 1
                else:
                    warnings += 1
        
        # Security Score Calculation
        security_score = (passed_tests / total_tests * 100) if total_tests > 0 else 0
        
        print(f"\nüèÜ SECURITY SCORE: {security_score:.1f}%")
        print(f"üìä SUMMARY: {passed_tests} PASSED | {failed_tests} FAILED | {warnings} WARNINGS")
        
        # Generate Recommendations
        recommendations = []
        
        if failed_tests > 0:
            recommendations.append("üî¥ CRITICAL: Address failed security tests immediately")
        
        if security_score < 80:
            recommendations.append("üü° MODERATE: Security score below 80% - improvements needed")
            
        if warnings > 0:
            recommendations.append("üü† ADVISORY: Review warning items for potential improvements")
        
        recommendations.extend([
            "üîê Enable HTTPS in production",
            "üõ°Ô∏è  Implement Web Application Firewall (WAF)",
            "üìä Set up security monitoring and alerting",
            "üîÑ Regular security audits and penetration testing",
            "üìù Document security incident response procedures"
        ])
        
        print(f"\nüí° SECURITY RECOMMENDATIONS:")
        for i, rec in enumerate(recommendations, 1):
            print(f"{i}. {rec}")
        
        return {
            'score': security_score,
            'total_tests': total_tests,
            'passed': passed_tests,
            'failed': failed_tests,
            'warnings': warnings,
            'recommendations': recommendations
        }

    def run_all_tests(self):
        """Execute all security tests"""
        print("üöÄ STARTING COMPREHENSIVE SECURITY PENETRATION TEST")
        print(f"üéØ Target: {self.base_url}")
        print(f"‚è∞ Started: {datetime.now()}")
        print("="*70)
        
        try:
            # Run all test categories
            self.test_brute_force_protection()
            self.test_session_security()
            self.test_input_validation()
            self.test_authentication_bypass()
            self.test_csrf_protection()
            self.test_security_headers()
            self.test_password_hashing()
            self.test_concurrent_attacks()
            
            # Generate final report
            report = self.generate_security_report()
            
            print(f"\n‚è∞ Completed: {datetime.now()}")
            return report
            
        except KeyboardInterrupt:
            print("\nüõë Security test interrupted by user")
        except Exception as e:
            print(f"\n‚ùå Security test error: {str(e)}")

if __name__ == "__main__":
    tester = SecurityTester()
    tester.run_all_tests()
